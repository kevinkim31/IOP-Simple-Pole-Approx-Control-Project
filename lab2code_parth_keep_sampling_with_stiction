#include <Arduino.h>
#include <math.h>
#include "geeWhiz.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

int MOT_PIN = A0;   // motor angle sensor
int BAL_PIN = A1;   // ball position sensor

// ================== Global Variables ======
volatile int motorADC = 0;     // gear angle reading from A/D
volatile int pos_counts = 0;       // ball position reading from A/D (not used for lab 1)
volatile bool new_data_available = false;  // flag to indicate new sensor data

// Angle calibration
const double m = -0.01427996661; // rad/ADC
const double offset = 435.0; // zero at ADC=435
const double SAT_LIMIT = 0.7;

const double m_ball = 3.0/2950.0; // rad/ADC
const double ball_offset = -71.0/236.0; // zero at ADC=435

// const double m_ball =  0.00022522522; // rad/ADC
// const double ball_offset = -0.2522727273; // zero at ADC=435

// const double m_ball =  0.00024600000; // rad/ADC
// const double ball_offset = -0.27600000; // zero at ADC=435

// ------- Controller Coefficients (EDIT THESE) -------
// D(z) = N(z)/D(z)
// N(z) = a0 + a1 z^-1 + a2 z^-2 + a3 z^-3 + a4 z^-4 + a5 z^-5 + a6 z^-6 + a7 z^-7
// D(z) = b0 + b1 z^-1 + b2 z^-2 + b3 z^-3 + b4 z^-4 + b5 z^-5 + b6 z^-6 + b7 z^-7 + b8 z^-8
double num[] = {0.0000000000 ,    3.35691708192918  ,  -7.04663430176872 ,   6.97634835237982 ,   -4.15645936949011  ,  4.58060382803318  ,  -6.14027996419204,    4.92529313916834  ,  -1.58492749103628};  // MATALB: num_ds [TAKE OUT FIRST ELEMENT FROM MATLAB (=0)]
double den[] = {1.00000000000 ,   -2.13319086758922   , 2.14467988019518   , -0.864588215839821   , -0.110317399308545  ,  0.284694217858913,    -0.0934966917459418  ,  -0.0522913361772104  ,  0.0499173735455755}; // MATLAB: den_ds 

const int NUM_LEN = sizeof(num) / sizeof(num[0]);
const int DEN_LEN = sizeof(den) / sizeof(den[0]);
const int E_HIST_LEN = (NUM_LEN > 0) ? NUM_LEN - 1 : 0;
const int U_HIST_LEN = (DEN_LEN > 0) ? DEN_LEN - 1 : 0;

// ===== History buffers =====
double eHist[E_HIST_LEN] = {0};
double uHist[U_HIST_LEN] = {0};



// (d) Stiction without beam + ball
// const double Vstick_CW = 0.147; // measured CW stiction (V)
// const double Vstick_CCW = 0.148; // measured CCW stiction (V)

// Stiction with beam + ball
const double V_zero = 0.58; // measured V that makes beam + ball stay in place at 0 deg, should stay positive here--> stuttering with steady state below zero
const double Vstick_CW = V_zero - 0.1; // measured CW stiction (V), then CW offset should be negative and small, V_zero - stick_CW
const double Vstick_CCW = V_zero + 0.1; // measured CCW stiction (V), then CCW offset should be positive and larger, V_zero + stick_CCW

// const double V_zero = 0.42;  // these values were calculted via physical measurements; no stuttering but cause steady state error with beam + ball
// const double Vstick_CW = V_zero - 0.35;
// const double Vstick_CCW = V_zero + 0.115;


// DEFINE OUTPUT Y (STEP_AMP) AND INPUT R (theta_ref) 
// ***************************************************
// const double STEP_AMP = 40.0 * M_PI / 180.0; // step input in radians
const double STEP_AMP = 0.1; 
double theta_ref = -0.1;
// ***************************************************



unsigned long t0;

void setup() {
  pinMode(A5, OUTPUT);
  Serial.begin(115200);
  delay(300);

  geeWhizBegin();
  set_control_interval_ms(9);

  t0 = millis();
  Serial.println("t_s,theta_ref,theta,u");
}

void loop() {
  // Only execute control when new sensor data is available

  if (new_data_available) {
    new_data_available = false;  // reset flag
    
    // Read sensors
    double theta = m * ((double)motorADC - offset); // scaled motor angle reading [radians]

    double ball_pos_m = m_ball*((double)pos_counts) + ball_offset; // scaled 

    // double ball_pos_m = m_ball*((double)pos_counts) + ball_offset; // scaled motor angle 

    // Reference: 0 rad until 3.0 s, then step to STEP_AMP
    unsigned long t_ms = millis() - t0;
    // Toggle every 3 seconds: -0.7 for first 3s, 0.7 for next 3s, repeat
    int period_count = (t_ms / 10000) % 2;
    if (period_count == 0) {
      theta_ref = -0.1;
    } else {
      theta_ref = 0.1;
    }

    // (f) Saturator: update theta ref if within range (+/- 0.7 rad)
    // if (t_ms >= 3000) {
    //   if (STEP_AMP < (-SAT_LIMIT)) {
    //     theta_ref = -SAT_LIMIT;
    //   }
    //   else if (STEP_AMP > (SAT_LIMIT)) {
    //     theta_ref = SAT_LIMIT;
    //   }
    //   else {
    //     theta_ref = STEP_AMP;
    //   }
    // }

    double e = theta_ref - theta;

    // const double E_DB_ENTER = 0.030;   // enter deadband at |e| ≤ 0.01 rad
    // const double E_DB_EXIT  = 0.020;   // leave deadband at |e| ≥ 0.02 rad
    // static bool in_deadband = false;

    //     // ---- deadband with hysteresis ----
    // if (in_deadband) {
    //   if (fabs(e) >= E_DB_EXIT) in_deadband = false;
    // } else {
    //   if (fabs(e) <= E_DB_ENTER) in_deadband = true;
    // }

    double u = num[0] * e;

    for (int i = 0; i < E_HIST_LEN; ++i) {
      u += num[i + 1] * eHist[i];
    }

    for (int i = 0; i < U_HIST_LEN; ++i) {
      u -= den[i + 1] * uHist[i];
    }

    u /= den[0];

    //     // ---- proportional part (your existing gain) ----
    // double u_corr = num[0] * e;

    // ---- constant gravity/stiction feed-forward ----
    // double u_corr = (in_deadband ? 0.0 : u); 

    double u_stiction = u;

    // if (u_stiction > 0.0 && !in_deadband) u_stiction += Vstick_CW;
    // else if (u_stiction < 0.0 && !in_deadband) u_stiction -= Vstick_CCW;
    // else u_stiction += V_zero;
    // setMotorVoltage(u_stiction*-1.0); // so actually negative to go CCW, before this CCW vals are all positive

    // if (!in_deadband) {
    //   if (u > 0.0) u += Vstick_CW;
    //   else if (u < 0.0) u += Vstick_CCW;
    // }
    // double u_stiction = u;

    if (u_stiction > 0.0) u_stiction += Vstick_CW;
    else if (u_stiction < 0.0) u_stiction -= Vstick_CCW;
    setMotorVoltage(u_stiction*-1.0);

    // if (u > 0.0) u += Vstick_CW;
    // else if (u < 0.0) u += Vstick_CCW;
    // setMotorVoltage(u*-1.0); 
    
    // ====== Update histories AFTER computing u ======
    // shift u history
    for (int i = U_HIST_LEN - 1; i > 0; --i) {
      uHist[i] = uHist[i-1];
    }
    if (U_HIST_LEN > 0) {
      uHist[0] = u;
    }

    // shift e history
    for (int i = E_HIST_LEN - 1; i > 0; --i) {
      eHist[i] = eHist[i-1];
    }
    if (E_HIST_LEN > 0) {
      eHist[0] = e;
    }

    // Logging
    static uint8_t decim = 0;
    if (++decim >= 10) {   // print every 10th sample, with set_control_interval_ms(2) in setup, sampling time is 20ms
      decim = 0;
      Serial.print(t_ms / 1000.0, 4);  Serial.print(",");
      Serial.print(theta_ref, 6);       Serial.print(",");
      Serial.print(theta, 6);           Serial.print(",");
      // Serial.print(u, 4); Serial.print(",");
      Serial.print(ball_pos_m,6); Serial.print(",");
      Serial.println(pos_counts);          //adc
    }
  }
}

void interval_control_code(void) {
  // Read sensors
  int motor = analogRead(MOT_PIN);
  int ball  = analogRead(BAL_PIN); // not used for lab 1

  motorADC = motor;
  pos_counts = ball; // not used for lab 1
  new_data_available = true;  // signal that new data is ready

  // square wave on A5 to check ISR rate on scope
  digitalWrite(A5, !digitalRead(A5));
}