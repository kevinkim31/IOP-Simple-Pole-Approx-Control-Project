#include <Arduino.h>
#include <math.h>
#include "geeWhiz.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

int MOT_PIN = A0;   // motor angle sensor
int BAL_PIN = A1;   // ball position sensor

// ================== Global Variables ======
volatile int motorADC = 0;     // gear angle reading from A/D
volatile int pos_counts = 0;       // ball position reading from A/D (not used for lab 1)
volatile bool new_data_available = false;  // flag to indicate new sensor data

// (c) Angle calibration
const double m = -0.01427996661; // rad/ADC
const double offset = 435.0; // zero at ADC=435
const double SAT_LIMIT = 0.7;

// ------- Controller Coefficients (EDIT THESE) -------
// D(z) = N(z)/D(z)
// N(z) = a0 + a1 z^-1 + a2 z^-2 + a3 z^-3 + a4 z^-4 + a5 z^-5 + a6 z^-6 + a7 z^-7
// D(z) = b0 + b1 z^-1 + b2 z^-2 + b3 z^-3 + b4 z^-4 + b5 z^-5 + b6 z^-6 + b7 z^-7 + b8 z^-8
double num[] = {3.320300000000000, -0.327978060921322, 0.874376865042969, 0.812670528101658, 0.741628371891472, -0.743415965647242, 0.0, 0.0};          // {a0..a7}
double den[] = {1.000000000000000, -0.097575071582660,  0.217238776883407,  0.143088093847746,  0.087300594719428 , 0.056087651795705,  0.017702633142652, 0.0, 0.0};   // {b0..b8}

const int NUM_LEN = sizeof(num) / sizeof(num[0]);
const int DEN_LEN = sizeof(den) / sizeof(den[0]);
const int E_HIST_LEN = (NUM_LEN > 0) ? NUM_LEN - 1 : 0;
const int U_HIST_LEN = (DEN_LEN > 0) ? DEN_LEN - 1 : 0;

// ===== History buffers =====
// uHist[0]=u[k-1], ..., uHist[7]=u[k-8] (8 poles)
// eHist[0]=e[k-1], ..., eHist[7]=e[k-8] (8 poles)
double eHist[E_HIST_LEN] = {0};
double uHist[U_HIST_LEN] = {0};



// (d) Stiction
const double Vstick_CW = 0.147; // measured CW stiction (V)
const double Vstick_CCW = 0.148; // measured CCW stiction (V)

// with ball beam:
const double V_zero = -0.42; // measured V that makes beam + ball stay in place at 0 deg
// const double Vstick_CW = V_zero + 0.3; // measured CW stiction (V)
// const double Vstick_CCW = V_zero - 0.115; // measured CCW stiction, start position on the right (V)
// const double Vstick_CCW = V_zero - 0.1; // measured CCW stiction, start position on the right (V)
// 0.1m from left end
// const double Vstick_CW = V_zero + 0.35; // measured CW stiction (V)
// const double Vstick_CCW = V_zero - 0.115; // measured CCW stiction, start position on the right (V)
// const double Vstick_CCW = V_zero - 0.041;


double theta_ref = 0.0;


// (e) P-control step test
const double Kp = 25.0; // Proportional constant
const double STEP_AMP = 40.0 * M_PI / 180.0; // step input in radians
unsigned long t0;

void setup() {
  pinMode(A5, OUTPUT);
  Serial.begin(115200);
  delay(300);

  geeWhizBegin();
  set_control_interval_ms(20);

  t0 = millis();
  Serial.println("t_s,theta_ref,theta,u");
}

void loop() {
  // Only execute control when new sensor data is available
  if (new_data_available) {
    new_data_available = false;  // reset flag
    
    // Read sensors
    double theta = m * ((double)motorADC - offset); // scaled motor angle reading [radians]


    // Reference: 0 rad until 3.0 s, then step to STEP_AMP
    unsigned long t_ms = millis() - t0;
    // (f) Saturator: update theta ref if within range (+/- 0.7 rad)
    if (t_ms >= 3000) {
      if (STEP_AMP < (-SAT_LIMIT)) {
        theta_ref = -SAT_LIMIT;
      }
      else if (STEP_AMP > (SAT_LIMIT)) {
        theta_ref = SAT_LIMIT;
      }
      else {
        theta_ref = STEP_AMP;
      }
    }

   // P controller
    double e = theta_ref - theta;
    double u = num[0] * e;

    for (int i = 0; i < E_HIST_LEN; ++i) {
      u += num[i + 1] * eHist[i];
    }

    for (int i = 0; i < U_HIST_LEN; ++i) {
      u -= den[i + 1] * uHist[i];
    }

    u /= den[0];

    u_stiction = u;

    if (u_stiction > 0.0) u_stiction += Vstick_CW;
    else if (u_stiction < 0.0) u_stiction -= Vstick_CCW;
    setMotorVoltage(u_stiction*-1.0);
    
    // ====== Update histories AFTER computing u ======
    // shift u history
    for (int i = U_HIST_LEN - 1; i > 0; --i) {
      uHist[i] = uHist[i-1];
    }
    if (U_HIST_LEN > 0) {
      uHist[0] = u;
    }

    // shift e history
    for (int i = E_HIST_LEN - 1; i > 0; --i) {
      eHist[i] = eHist[i-1];
    }
    if (E_HIST_LEN > 0) {
      eHist[0] = e;
    }

    // Logging
    static uint8_t decim = 0;
    // if (++decim >= 10) {   // print every 10th sample, with set_control_interval_ms(2) in setup, sampling time is 20ms
      decim = 0;
      Serial.print(t_ms / 1000.0, 4);  Serial.print(",");
      Serial.print(theta_ref, 6);       Serial.print(",");
      Serial.print(theta, 6);           Serial.print(",");
      Serial.println(u, 4);
    // }
  }
}

void interval_control_code(void) {
  // Read sensors
  int motor = analogRead(MOT_PIN);
  int ball  = analogRead(BAL_PIN); // not used for lab 1

  motorADC = motor;
  pos_counts = ball; // not used for lab 1
  new_data_available = true;  // signal that new data is ready

  // square wave on A5 to check ISR rate on scope
  digitalWrite(A5, !digitalRead(A5));
}
