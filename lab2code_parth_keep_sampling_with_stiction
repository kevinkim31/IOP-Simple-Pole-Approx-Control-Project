include <Arduino.h>
#include <math.h>
#include "geeWhiz.h"

#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

int MOT_PIN = A0;   // motor angle sensor
int BAL_PIN = A1;   // ball position sensor

// ================== Global Variables ======
volatile int motorADC = 0;     // gear angle reading from A/D
volatile int pos_counts = 0;       // ball position reading from A/D (not used for lab 1)
volatile bool new_data_available = false;  // flag to indicate new sensor data

// Angle calibration
const double m = -0.01427996661; // rad/ADC
const double offset = 435.0; // zero at ADC=435
const double SAT_LIMIT = 0.7;

const double m_ball = 3.0/2950.0; // rad/ADC
const double ball_offset = -71.0/236.0; // zero at ADC=435

// const double m_ball =  0.00022522522; // rad/ADC
// const double ball_offset = -0.2522727273; // zero at ADC=435

// const double m_ball =  0.00024600000; // rad/ADC
// const double ball_offset = -0.27600000; // zero at ADC=435

// ------- Controller Coefficients (EDIT THESE) -------
// D(z) = N(z)/D(z)
// N(z) = a0 + a1 z^-1 + a2 z^-2 + a3 z^-3 + a4 z^-4 + a5 z^-5 + a6 z^-6 + a7 z^-7
// D(z) = b0 + b1 z^-1 + b2 z^-2 + b3 z^-3 + b4 z^-4 + b5 z^-5 + b6 z^-6 + b7 z^-7 + b8 z^-8
double num[] = {4.28571428571429,    -7.47346203192054,    6.50702868019854,   -2.06203123396217,    -0.102634444532833,    -0.772187468930284,    2.58979133331801,    -1.39345261821552};  // MATALB: num_ds [TAKE OUT FIRST ELEMENT FROM MATLAB (=0)]
double den[] = {1.00000000000000 ,   -1.74291294381461,    1.50006108548708,    -0.494398873930484,    -0.0351683941949983,    0.126070763073284,    -0.0221429806981165,    -0.00266656583287233,    0.0179586003866532}; // MATLAB: den_ds 

// const int NUM_LEN = sizeof(num) / sizeof(num[0]);
// const int DEN_LEN = sizeof(den) / sizeof(den[0]);
const int NUM_LEN = 8;
const int DEN_LEN = 9;
const int E_HIST_LEN = (NUM_LEN > 0) ? NUM_LEN - 1 : 0;
const int U_HIST_LEN = (DEN_LEN > 0) ? DEN_LEN - 1 : 0;

// ===== History buffers =====
double eHist[E_HIST_LEN] = {0};
double uHist[U_HIST_LEN] = {0};



// (d) Stiction without beam + ball
// const double Vstick_CW = 0.147; // measured CW stiction (V)
// const double Vstick_CCW = 0.148; // measured CCW stiction (V)

// Stiction with beam + ball
// const double V_zero = 0.58; // measured V that makes beam + ball stay in place at 0 deg, should stay positive here--> stuttering with steady state below zero
// const double Vstick_CW = V_zero - 0.1; // measured CW stiction (V), then CW offset should be negative and small, V_zero - stick_CW
// const double Vstick_CCW = V_zero + 0.1; // measured CCW stiction (V), then CCW offset should be positive and larger, V_zero + stick_CCW

const double V_zero = 0.42;  // these values were calculted via physical measurements; no stuttering but cause steady state error with beam + ball
// const double Vstick_CW = V_zero - 0.35;
// const double Vstick_CCW = V_zero + 0.115;

// without ball
// const double Vstick_CW = 0.3;
// const double Vstick_CCW = 0.1;
// with ball
const double Vstick_CW = 0.2;
const double Vstick_CCW = 0.175;


// DEFINE OUTPUT Y (STEP_AMP) AND INPUT R (theta_ref) 
// ***************************************************
// const double STEP_AMP = 40.0 * M_PI / 180.0; // step input in radians
const double STEP_AMP = 0.7; 
double theta_ref = -0.7;
// ***************************************************



unsigned long t0;

void setup() {
  pinMode(A5, OUTPUT);
  Serial.begin(115200);
  delay(300);

  geeWhizBegin();
  set_control_interval_ms(9);

  t0 = millis();
  Serial.println("t_s,theta_ref,theta,u");
}

void loop() {
  // Only execute control when new sensor data is available

  if (new_data_available) {
    new_data_available = false;  // reset flag
    
    // Read sensors
    double theta = m * ((double)motorADC - offset); // scaled motor angle reading [radians]

    double ball_pos_m = m_ball*((double)pos_counts) + ball_offset; // scaled 

    // double ball_pos_m = m_ball*((double)pos_counts) + ball_offset; // scaled motor angle 

    // Reference: 0 rad until 3.0 s, then step to STEP_AMP
    unsigned long t_ms = millis() - t0;
    // Toggle every 3 seconds: -0.7 for first 3s, 0.7 for next 3s, repeat
    int period_count = (t_ms / 8000) % 2;
    if (period_count == 0) {
      theta_ref = -0.7;
    } else {
      theta_ref = 0.7;
    }

    //(f) Saturator: update theta ref if within range (+/- 0.7 rad)
    // if (t_ms >= 3000) {
    //   if (STEP_AMP < (-SAT_LIMIT)) {
    //     theta_ref = -SAT_LIMIT;
    //   }
    //   else if (STEP_AMP > (SAT_LIMIT)) {
    //     theta_ref = SAT_LIMIT;
    //   }
    //   else {
    //     theta_ref = STEP_AMP;
    //   }
    // }

    double e = theta_ref - theta;

    double u = num[0] * e;

    for (int i = 0; i < E_HIST_LEN; ++i) {
      u += num[i + 1] * eHist[i];
    }

    for (int i = 0; i < U_HIST_LEN; ++i) {
      u -= den[i + 1] * uHist[i];
    }

    u /= den[0];


    double u_stiction = u*-1.0;

    // if (abs(e) >= 0.01) {
      if (theta_ref > 0.0) u_stiction -= Vstick_CW; // switch <, > if needed GOOD
      else if (theta_ref < 0.0) u_stiction  -= Vstick_CCW; //+ve theta_ref=CCW
    // }

    // if (abs(e) < 0.02) {
    //   // u_stiction=uHist[0];
    //   if (u_stiction > 0.0) u_stiction = Vstick_CW; // switch <, > if needed
    //   else if (u_stiction < 0.0) u_stiction = -Vstick_CCW;
    // }

    //voltage saturator
    if (u_stiction < (-6.0)) {
      u_stiction = -6.0;
    }
    else if (u_stiction > (6.0)) {
      u_stiction = 6.0;
    }
    else {
      u_stiction = u_stiction;
    }
    // setMotorVoltage(u_stiction*-1.0);
    setMotorVoltage(u_stiction);
    
    // ====== Update histories AFTER computing u ======
    // shift u history
    for (int i = U_HIST_LEN - 1; i > 0; --i) {
      uHist[i] = uHist[i-1];
    }
    if (U_HIST_LEN > 0) {
      uHist[0] = u;
    }

    // shift e history
    for (int i = E_HIST_LEN - 1; i > 0; --i) {
      eHist[i] = eHist[i-1];
    }
    if (E_HIST_LEN > 0) {
      eHist[0] = e;
    }

    // Logging
    static uint8_t decim = 0;
    // if (++decim >= 10) {   // print every 10th sample, with set_control_interval_ms(2) in setup, sampling time is 20ms
      decim = 0;
      Serial.print(t_ms / 1000.0, 4);  Serial.print(",");
      Serial.print(theta_ref, 6);       Serial.print(",");
      Serial.print(theta, 6);           Serial.print(",");
      Serial.print(u_stiction, 4); Serial.print(",");
      Serial.println(ball_pos_m,6);
      // Serial.println(pos_counts);          //adc
    // }
  }
}

void interval_control_code(void) {
  // Read sensors
  int motor = analogRead(MOT_PIN);
  int ball  = analogRead(BAL_PIN); // not used for lab 1

  motorADC = motor;
  pos_counts = ball; // not used for lab 1
  new_data_available = true;  // signal that new data is ready

  // square wave on A5 to check ISR rate on scope
  digitalWrite(A5, !digitalRead(A5));
}